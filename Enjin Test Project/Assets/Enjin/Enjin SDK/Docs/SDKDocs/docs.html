<!DOCTYPE html>
<html lang='en'>

  <head>
    <meta charset='utf-8'>
    <meta name='description' content='Enjin SDK Documentation'>
    <meta name='author' content='Enjin'>

    <!-- Custom styling for the documentation. -->
    <style>
      main header                 { margin: 0.0em 0.0em 1.0em 0.0em; }
      section header              { margin: 0.0em 0.0em 1.0em 0.0em; }
      section p                   { margin: 0.0em 0.0em 1.0em 0.5em; }
      article                     { margin: 0.0em 0.0em 1.0em 0.0em;
                                    border-top-style: dotted;
                                    border-right-style: solid;
                                    border-bottom-style: dotted;
                                    border-left-style: solid;        }
      article header              { margin: 0.0em 0.0em 0.5em 0.5em; }
      article summary             { margin: 0.0em 0.0em 1.0em 1.0em; }
      article details             { margin: 0.0em 0.0em 1.0em 1.0em; }
      article details p           { margin: 0.0em 0.0em 1.0em 1.0em; }
      article details .example    { margin: 0.0em 0.0em 1.0em 0.0em; }
      article details .parameter  { margin: 0.0em 0.0em 1.0em 1.0em; }
      article details .highlight  { margin: 0.0em 0.0em 1.0em 1.0em; }
      article details button      { margin: 0.0em 0.0em 1.0em 1.0em; }
      main footer                 { margin: 0.0em 0.0em 0.0em 0.0em; }
    </style>

    <!-- Custom styling for the Prism.js syntax highlighting. -->
    <style>
      /*
      PrismJS 1.15.0
      https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript+csharp+graphql

      Solarized Color Schemes originally by Ethan Schoonover
      http://ethanschoonover.com/solarized

      Ported for PrismJS by Hector Matos
      Website: https://krakendev.io
      Twitter Handle: https://twitter.com/allonsykraken)
      */

      code[class*="language-"],
      pre[class*="language-"] {
      	color: #657b83; /* base00 */
      	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
      	text-align: left;
      	white-space: pre;
      	word-spacing: normal;
      	word-break: normal;
      	word-wrap: normal;

      	line-height: 1.5;

      	-moz-tab-size: 4;
      	-o-tab-size: 4;
      	tab-size: 4;

      	-webkit-hyphens: none;
      	-moz-hyphens: none;
      	-ms-hyphens: none;
      	hyphens: none;
      }

      pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
      code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
      	background: #073642; /* base02 */
      }

      pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
      code[class*="language-"]::selection, code[class*="language-"] ::selection {
      	background: #073642; /* base02 */
      }

      /* Code blocks */
      pre[class*="language-"] {
      	padding: 1em;
      	margin: .5em 0;
      	overflow: auto;
      	border-radius: 0.3em;
      }

      :not(pre) > code[class*="language-"],
      pre[class*="language-"] {
      	background-color: #fdf6e3; /* base3 */
      }

      /* Inline code */
      :not(pre) > code[class*="language-"] {
      	padding: .1em;
      	border-radius: .3em;
      }

      .token.comment,
      .token.prolog,
      .token.doctype,
      .token.cdata {
      	color: #93a1a1; /* base1 */
      }

      .token.punctuation {
      	color: #586e75; /* base01 */
      }

      .namespace {
      	opacity: .7;
      }

      .token.property,
      .token.tag,
      .token.boolean,
      .token.number,
      .token.constant,
      .token.symbol,
      .token.deleted {
      	color: #268bd2; /* blue */
      }

      .token.selector,
      .token.attr-name,
      .token.string,
      .token.char,
      .token.builtin,
      .token.url,
      .token.inserted {
      	color: #2aa198; /* cyan */
      }

      .token.entity {
      	color: #657b83; /* base00 */
      	background: #eee8d5; /* base2 */
      }

      .token.atrule,
      .token.attr-value,
      .token.keyword {
      	color: #859900; /* green */
      }

      .token.function,
      .token.class-name {
      	color: #b58900; /* yellow */
      }

      .token.regex,
      .token.important,
      .token.variable {
      	color: #cb4b16; /* orange */
      }

      .token.important,
      .token.bold {
      	font-weight: bold;
      }
      .token.italic {
      	font-style: italic;
      }

      .token.entity {
      	cursor: help;
      }
    </style>

    <title>
      Enjin SDK Documentation
    </title>
  </head>

  <body>
    <main>
      <header>
        Welcome to the documentation for the Enjin SDK. Here you will find useful instructions for interacting with the tools we provide to make the true ownership of in-game items possible. This page is a customized landing menu to explore general, useful GraphQL queries with links to their equivalent functions in Unity. If you'd like to explore the full automatically-generated Unity documentation, feel free to peruse the included <a href="doxygen/index.html" target="_blank">Doxygen resources</a>.
      </header>

      <section>
        <header>
          About the Trusted Platform
        </header>

        <p>
          The Trusted Platform is Enjin's intermediary server to make interacting with our deployed ERC-1155 smart contract implementation easier.
        </p>

        <p>
          Trusted Platforms are deployed to specific URLs and listen for POSTed GraphQL queries. In this documentation, the Trusted Platform at the following URL will be queried:
          <br>
          <input id='platform-url' type='text' value='https://master.tp-enj.in/graphql/'>
        </p>
      </section>

      <section>
        <header>
          Operations Involving Users
        </header>

        <p>
          Users are an abstraction on the Trusted Platform for someone with login details. This encompasses someone who might be a Player, an Admin, or a Platform Owner. Players are Users who do not have any special permissions within a single app. They are normal, unelevated, and the majority of Users. Admins are Users with elevated permissions within a single app, typically the developer. This is a good Role to assign to something like a server which proxies requests on behalf of Players. Platform Owners have elevated privileges across an entire Trusted Platform. A use case for such a Role is an over-arching developer Role which wants to access multiple items from multiple individual apps on that single instance of a Trusted Platform. More generally, Roles are custom collections of permissions that can be created and attached to specific Users in order to restrict some parts of the SDK functionality. The Player, Admin, and Platform Owner permissions described here represent what is available as default Roles.
        </p>

        <!-- Getting Access Credentials -->
        <article>
          <header>
            Getting Access Credentials
          </header>
          <summary>
            Most functionality that this SDK supports, whether querying Player data or requesting operations on CryptoItems, requires an access token to use.
          </summary>
          <details>
            <p>
              This method retrieves an access token given a User's credentials. This access token is used by including it in an 'Authorization' header on the outbound POST request to Enjin's Trusted Platform. The access token serves to identify the User and makes sure that only those with valid permissions can enact Trusted Platform operations. Executing this example will set the access token which is used to validate requests for all other examples on this page.
            </p>

            <section class='example'>
              <p>
                Logging a User into a Trusted Platform requires their email address and password. The GraphQL query to do so is as follows:
              </p>

              <pre><code class='query-display highlight language-graphql'>
query login($email:String!, $password:String!) {
  results: EnjinOauth(email: $email, password: $password) {
    id
    access_tokens
    roles {
      name
    }
    identities {
      id
      app_id
      ethereum_address
    }
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='email' placeholder='Email'>
              <br>
              <input class='parameter' type='text' name='password' placeholder='Password'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In the Unity SDK, functionality identical to this call is implemented by the <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#ab9af06457f065cebd30f28ef5d20cf92" target="_blank">Enjin.Login(string username, string password)</a> method. This method takes the same input of a username and password before returning a User object containing that User's id, access token, an array of Roles, and an array of Identities. In a similar vein, the <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#abd0ebc7f68d479d83a8d365c52d35993" target="_blank">Enjin.VerifyLogin(string username, string password)</a> method performs an identical login query but only returns the User, success state, and does not alter global AppID state. Its purpose is to validate the correct login of a User for game servers which are proxying requests. The SDK also includes <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#accf26efc6912b460998fd39e471e8acb" target="_blank">StartPlatform()</a> methods which initialize the SDK as a whole to a specific Trusted Platform with a specific User to issue requests, which is very useful for signing in with a managing Admin.
              </p>
            </section>
          </details>
        </article>

        <!-- Getting a User's Items -->
        <article>
          <header>
            Getting a User's Items
          </header>
          <summary>
            With access token in hand, we can retrieve a User's Items.
          </summary>
          <details>
            <p>
              This method, given a User's access token, will send a request to the Trusted Platform which returns a User's inventory for a specified Identity. An Identity is tied to a single wallet address, and a User can have many of them across different Trusted Platform apps. Users can also have a single Identity with items from multiple apps.
            </p>

            <section class='example'>
              <p>
                Retrieving a User's inventory from the Trusted Platform requires knowing the ID for an Identity of theirs. The GraphQL query to do so is as follows:
              </p>

              <pre><code class='query-display highlight language-graphql'>
query getAllItems($identityId: Int!) {
  result: EnjinIdentities(id: $identityId) {
    tokens(pagination: {page: 1}, include_creator_tokens: true) {
      items {
        app_id
        index
        itemURI
        token_id
        name
        creator
        totalSupply
        reserve
        circulatingSupply
        supplyModel
        meltValue
        meltFeeRatio
        meltFeeMaxRatio
        transferable
        transferFeeSettings {
          type
          token_id
          value
        }
        nonFungible
        icon
        balance
        isCreator
        markedForDelete
      }
      cursor {
        total
        hasPages
        perPage
        currentPage
      }
    }
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='identityId' placeholder='Identity ID'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have retrieved the first page of a User's inventory from the Trusted Platform. Please note that the "page" parameter may be changed to query for additional items as desired by your game's needs. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#a91d65b738b2b58ede69122afb8e83501" target="_blank">Enjin.GetAllItems(int identityID)</a> which will return a workable list of all Items tied to an Identity and their relevant metadata.
              </p>
            </section>
          </details>
        </article>

        <!-- Creating a New User -->
        <article>
          <header>
            Creating a New User
          </header>
          <summary>
            A game developer can, using their privileged Admin User, create additional Users for their players.
          </summary>
          <details>
            <p>
              This method, given an Admin's access token, will send a request to the Trusted Platform which creates a new User and Identity with the specified details. This Identity will need to be linked at some point to a Player's wallet using the Enjin Wallet App before it can be particularly useful. The use case for this sort of User crreation is to let game developers leverage the Trusted Platform as a kind of authorization and credentials backend in supporting User login.
            </p>

            <section class='example'>
              <p>
                Creating a new User on the Trusted Platform requires specifying a name, password, unique email, and role. All fields are specified as text strings, with the Role matching an existing value known to the Trusted Platform. The User is created under the specified App that the caller is an Admin of. The GraphQL query to do so is as follows:
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation createUser($name: String!, $password: String!, $email: String!, $role: String!) {
  user: CreateEnjinUser(name: $name, password: $password, email: $email, role: $role) {
    id
    name
    email
    roles {
      id
      name
      permissions {
        id
        name
      }
    }
    identities {
      id
      ethereum_address
      linking_code
      updated_at
      created_at
      fields {
        key
        value
        searchable
        displayable
        unique
      }
    }
    access_tokens
    created_at
    updated_at
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='name' placeholder='Name'>
              <br>
              <input class='parameter' type='text' name='password' placeholder='Password'>
              <br>
              <input class='parameter' type='text' name='email' placeholder='Email'>
              <br>
              <input class='parameter' type='text' name='role' placeholder='Role'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have created a new User on the Trusted Platform. In order for this call to succeed, the caller must have permissions to create Users on their App. Typically, this is done by letting the caller have the Admin or Platform Owner Roles. This new User is automatically created with a single Identity for the caller's App. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#ad3766c8ed4e8fdb68f065177d4046027" target="_blank">CreateUser(string username, string email, string password, string role)</a> which will create a new User with new Identity and return it such that we might link it to a Player's wallet.
              </p>
            </section>
          </details>
        </article>

        <!-- Linking a Wallet -->
        <article>
          <header>
            Linking a Wallet
          </header>
          <summary>
            Newly-created Identities include codes that players can enter in the Enjin Wallet to link an Ethereum address for handling Items.
          </summary>
          <details>
                      <!--
            <p>
              This method, given an Admin's access token, will send a request to the Trusted Platform which creates a new User and Identity with the specified details. This Identity will need to be linked at some point to a Player's wallet using the Enjin Wallet App before it can be particularly useful. The use case for this sort of User crreation is to let game developers leverage the Trusted Platform as a kind of authorization and credentials backend in supporting User login.
            </p>

            <section class='example'>
              <p>
                Creating a new User on the Trusted Platform requires specifying a name, password, unique email, and role. All fields are specified as text strings, with the Role matching an existing value known to the Trusted Platform. The User is created under the specified App that the caller is an Admin of. The GraphQL query to do so is as follows:
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation createUser($name: String!, $password: String!, $email: String!, $role: String!) {
  user: CreateEnjinUser(name: $name, password: $password, email: $email, role: $role) {
    id
    name
    email
    roles {
      id
      name
      permissions {
        id
        name
      }
    }
    identities {
      id
      ethereum_address
      linking_code
      updated_at
      created_at
      fields {
        key
        value
        searchable
        displayable
        unique
      }
    }
    access_tokens
    created_at
    updated_at
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='name' placeholder='Name'>
              <br>
              <input class='parameter' type='text' name='password' placeholder='Password'>
              <br>
              <input class='parameter' type='text' name='email' placeholder='Email'>
              <br>
              <input class='parameter' type='text' name='role' placeholder='Role'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have created a new User on the Trusted Platform. In order for this call to succeed, the caller must have permissions to create Users on their App. Typically, this is done by letting the caller have the Admin or Platform Owner Roles. This new User is automatically created with a single Identity for the caller's App. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#ad3766c8ed4e8fdb68f065177d4046027" target="_blank">CreateUser(string username, string email, string password, string role)</a> which will create a new User with new Identity and return it such that we might link it to a Player's wallet.
              </p>
            -->
              <p>
                In the Unity SDK, the intended workflow for linking a User's wallet to an Identity such that your game might retrieve their Ethereum address is to register a listening callback and display a linking code. The User will then enter this code in their Enjin Wallet, at which time your callback function will be triggered. The code can be retrieved from the "linking_code" field of the appropriate Identity under the User object returned from methods such as <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#abd0ebc7f68d479d83a8d365c52d35993" target="_blank">Enjin.VerifyLogin(string username, string password)</a> or <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#ad3766c8ed4e8fdb68f065177d4046027" target="_blank">CreateUser(string username, string email, string password, string role)</a>. If the Identity has already been linked, then the "linking_code" field will be null and an "ethereum_address" will be present.
              </p>

              <p>
                An example of the Unity SDK's <a href='doxygen/class_enjin_s_d_k_1_1_enjin.html#a5935d76a851168b2b5c5a15f0bef753e' target='_blank'>Enjin.ListenForLink(int identityID, System.Action&lt;RequestEvent&gt; listener)</a> where "identityId" is the identifier of a specific Identity under a User which you as developer would like to listen for linking on. That is, this is the Identity containing the code which you should be displaying to the player. The "linkingData" parameter is an object of type <a href='doxygen/class_enjin_s_d_k_1_1_request_event.html' target='_blank'>RequestEvent</a> and includes some potentially-useful metadata about the linking event.
              </p>

              <pre><code class='output-display highlight language-javascript'>
Enjin.ListenForLink(identityId, linkingData => {
  Debug.Log("Linked!");
});
              </code></pre>
            </section>
          </details>
        </article>

        <!-- Sending an Item to a User -->
        <article>
          <header>
            Sending an Item to a User
          </header>
          <summary>
            Here we learn how to send an Item from the caller's wallet to a User.
          </summary>
          <details>
            <p>
              This method, given an access token, will send a request to the Trusted Platform which creates a new item transfer request to be either accepted or denied in the Enjin Wallet of the access token's owner. This second factor of accepting or denying the transfer request on a separate service is a security feature to protect against potentially malicious developers, server proxies, or compromised machines.
            </p>

            <section class='example'>
              <p>
                Creating an Item transfer request on the Trusted Platform requires specifying an identifier for the sender's Identity, an identifier for the recipient's Identity, the identifier for the Item to transfer, and an amount of that Item to transfer. Once the request appears in the sender's wallet and is accepted, the Item is moved from the Ethereum address that is linked to the sending Identity and into the Ethereum address that is linked to the recipient's Identity. To do this successfully, the sender requires some Ether to cover gas costs. They might also potentially require some Enjin Coin to cover transaction fees specified by the game developer. The GraphQL query to do so is as follows:
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation sendItem($identityId: Int!, $recipientIdentityId: Int!, $tokenId: String!, $value: Int!) {
  CreateEnjinRequest(type: SEND, identity_id: $identityId, send_token_data: { recipient_identity_id: $recipientIdentityId, token_id: $tokenId, value: $value }) {
    id
    encoded_data
    state
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='identityId' placeholder='Sender Identity ID'>
              <br>
              <input class='parameter' type='text' name='recipientIdentityId' placeholder='Recipient Identity ID'>
              <br>
              <input class='parameter' type='text' name='tokenId' placeholder='Item ID'>
              <br>
              <input class='parameter' type='text' name='value' placeholder='Amount'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have created an Item transfer request for the sender to either accept or deny using their Enjin Wallet. This has a myriad of uses in gameplay, such as letting a game server reward a player with some Item based on their in-game actions. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#a1dd110b494d572b3b7eccb671585dbb2" target="_blank">SendCryptoItemRequest(int identityID, string tokenID, int recipientID, int value, System.Action&lt;RequestEvent&gt; callback)</a> which will create an identical request for Item transfer as well as registering a callback for listening to successful transfer. This callback can be used in similar fashion to the "Linking a Wallet" example.
              </p>
            </section>
          </details>
        </article>

        <!-- Creating Trade Requests -->
        <article>
          <header>
            Creating Trade Requests
          </header>
          <summary>
            Here we learn how to create trade requests between Users. Trading empowers us to transfer Items in secure, atomic fashion.
          </summary>
          <details>
            <p>
              This method, given an access token, will send a request to the Trusted Platform which creates a new trade request to be either accepted or denied in the Enjin Wallet of the access token's owner. This second factor of accepting or denying the transfer request on a separate service is a security feature to protect against potentially malicious developers, server proxies, or compromised machines.
            </p>

            <section class='example'>
              <p>
                Creating a trade request on the Trusted Platform requires specifying an identifier for the sender's Identity, an identifier for the second party's Identity, the identifier for the Item being offered, an amount of the Item being offered, the identifier for the Item being asked for, and the amount of the Item being asked for. Once the request appears in the sender's wallet and is accepted, the second party must issue and accept a request to complete the trade. At this time, the Items are moved from the Ethereum addresses that are linked to their respective Identities and into each other's wallets. To do this successfully, the parties require some Ether to cover gas costs. They might also potentially require some Enjin Coin to cover transaction fees specified by the game developer. The GraphQL query to do so is as follows (note that this is just a sample query transferring a single type of Item; multiple Items can be transferred at once by extending what is inserted into the "asking_tokens" and "offering_tokens" arrays):
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation sendTrade($identityId: Int!, $askingTokenId: String!, $askingValue: Int!, $offeringTokenId: String!, $offeringValue: Int!, $secondPartyIdentityId: Int!) {
  result: CreateEnjinRequest(identity_id: $identityId, type: CREATE_TRADE, create_trade_data: { asking_tokens: [{ id: $askingTokenId, value: $askingValue }], offering_tokens: [{ id: $offeringTokenId, value: $offeringValue }], second_party_identity_id: $secondPartyIdentityId }) {
    id
    encoded_data
    state
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='identityId' placeholder='Sender Identity ID'>
              <br>
              <input class='parameter' type='text' name='secondPartyIdentityId' placeholder='Second Party Identity ID'>
              <br>
              <input class='parameter' type='text' name='askingTokenId' placeholder='Asking Item ID'>
              <br>
              <input class='parameter' type='text' name='askingValue' placeholder='Asking Item Amount'>
              <br>
              <input class='parameter' type='text' name='offeringTokenId' placeholder='Offering Item ID'>
              <br>
              <input class='parameter' type='text' name='offeringValue' placeholder='Offering Item Amount'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have created a trade request for the sender to either accept or deny using their Enjin Wallet. This has a myriad of uses in gameplay, such as letting a game server safely handle atomic swaps of Items. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#a10d26b82146e1650ae485325f936632a" target="_blank">Enjin.CreateTradeRequest(int senderIdentityID, CryptoItem[] itemsFromSender, int[] amountsFromSender, int secondPartyIdentityID, CryptoItem[] itemsFromSecondParty, int[] amountsFromSecondParty)</a> which will create an identical request for Item trading as well as registering a callback for listening to the first party accepting. This callback can be used in similar fashion to the "Linking a Wallet" example. The second party needs to accept this trade request using the "trade_id" value specified here as <a href='doxygen/class_enjin_s_d_k_1_1_request_event.html#ae7ac635d5ceb808ab248578d43093d05' target='_blank'>RequestEvent.request_id</a>.
              </p>
            </section>
          </details>
        </article>

        <!-- Completing Trade Requests -->
        <article>
          <header>
            Completing Trade Requests
          </header>
          <summary>
            Here we learn how to complete trade requests between Users as had been created by the last call. Trading empowers us to transfer Items in secure, atomic fashion.
          </summary>
          <details>
            <p>
              This method, given an access token, will send a request to the Trusted Platform which completes an outstanding trade request. The sender will be given the option to either accept or deny the trade in the Enjin Wallet. This second factor of accepting or denying the transfer request on a separate service is a security feature to protect against potentially malicious developers, server proxies, or compromised machines.
            </p>

            <section class='example'>
              <p>
                Completing a trade request on the Trusted Platform requires specifying an identifier for the sender's Identity and an identifier for the trade to complete. This trade identity is generated in response to the trade creation request. Once this request appears in the sender's wallet and is accepted, the items specified in the trade creation request will be swapped. The GraphQL query to do so is as follows:
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation sendTrade($identityId: Int!, $tradeId: String!) {
  result: CreateEnjinRequest(identity_id: $identityId, type: COMPLETE_TRADE, complete_trade_data: { trade_id: $tradeId }) {
    id
    encoded_data
    state
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='identityId' placeholder='Sender Identity ID'>
              <br>
              <input class='parameter' type='text' name='tradeId' placeholder='Trade ID'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have issued a trade completion request for the sender to either accept or deny a proposed trade using their Enjin Wallet. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#a423a2b4481219bcad6989a88a6b06615" target="_blank">Enjin.CompleteTradeRequest(int secondPartyID, string tradeID, System.Action&lt;RequestEvent&gt; callback)</a> which will create an identical complete trade request as well as register a callback for listening to the second party accepting. This callback can be used in similar fashion to the "Linking a Wallet" example. The second party needs to accept this trade request using the "trade_id" value specified here as <a href='doxygen/class_enjin_s_d_k_1_1_request_event.html#ae7ac635d5ceb808ab248578d43093d05' target='_blank'>RequestEvent.request_id</a> in the trade creation request.
              </p>
            </section>
          </details>
        </article>

        <!-- Creating Melt Requests -->
        <article>
          <header>
            Creating Melt Requests
          </header>
          <summary>
            Here we learn how to create melt requests whereby a User may destroy an Item and receive what amount of Enjin Coin had been staked to it at its creation.
          </summary>
          <details>
            <p>
              This method, given an access token, will send a request to the Trusted Platform which creates a request to melt an Item. The sender will be given the option to either accept or deny the melt operataion in the Enjin Wallet. This second factor of accepting or denying the transfer request on a separate service is a security feature to protect against potentially malicious developers, server proxies, or compromised machines.
            </p>

            <section class='example'>
              <p>
                Creating a melt request on the Trusted Platform requires specifying an identifier for the sender's Identity, an identifier for the Item being melted, and an amount of that Item to melt. Once this request appears in the sender's wallet and is accepted, the Items specified in the request will be melted to unlock their staked Enjin Coin. The GraphQL query to do so is as follows:
              </p>

              <p>
                Some calls to the Trusted Platform require specifying a particular App to operate on. This is one such call. The App is specified by prepending its identifier with an "@" to the front of the access token when sending that in the 'Authorization' header to the Trusted Platform. That is, the entire access token for operating on a specific App will look like "App ID"@"access token"; you can find potential App identifiers as the "app_id" field in the response to the "Getting Access Credentials" call.
              </p>

              <input id="appId" type='text' name='appId' placeholder='App ID'>

              <pre><code class='query-display highlight language-graphql'>
mutation meltToken($identityId: Int!, $tokenId: String!, $value: Int!) {
  request: CreateEnjinRequest(type: MELT, identity_id: $identityId, melt_token_data: { token_id: $tokenId, value: $value }) {
    id
    encoded_data
    state
  }
}
              </code></pre>

              <p>
                Pressing the 'Submit Query' button will POST the query above to the Trusted Platform endpoint, along with additional parameters encoded as follows:
              </p>

              <input class='parameter' type='text' name='identityId' placeholder='Sender Identity ID'>
              <br>
              <input class='parameter' type='text' name='tokenId' placeholder='Item ID'>
              <br>
              <input class='parameter' type='text' name='value' placeholder='Amount to Melt'>

              <pre><code class='parameter-display highlight language-javascript'>
{}
              </code></pre>

              <button class='submit-button'>Submit Query</button>

              <p>
                Here is the output response from the Trusted Platform:
              </p>

              <pre><code class='output-display highlight language-javascript'>
{
}
              </code></pre>

              <p>
                In this example query, we have issued a melt request for the sender to either accept or deny using their Enjin Wallet. The corresponding function in the Unity SDK to this GraphQL call is <a href="doxygen/class_enjin_s_d_k_1_1_enjin.html#acb6c36db0dfc21261a27a1aba7f63d63" target="_blank">Enjin.MeltTokens(int userIdentityID, string itemID, int amount, System.Action&lt;RequestEvent&gt; callback)</a> which will create an identical melt request as well as register a callback for listening to the User accepting. This callback can be used in similar fashion to the "Linking a Wallet" example.
              </p>
            </section>
          </details>
        </article>
      </section>

      <footer>
        Produced with love by Enjin, 12.21.2018.
      </footer>
    </main>

    <!-- Load jQuery from CDN. -->
    <script src='https://code.jquery.com/jquery-3.3.1.min.js' integrity='sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=' crossorigin='anonymous'></script>

    <!-- Script for handling constructed queries. -->
    <script type='text/javascript'>

      // Record the access token to send alongside all requests.
      var accessToken = '';

      // For every example block, construct an object of given parameters.
      $('.example').each((index, element) => {
        var platformUrl = $('#platform-url').val();
        var submitButton = $(element).find('.submit-button');
        var query = $(element).find('.query-display').html();
        var outputDisplay = $(element).find('.output-display');
        submitButton.click(() => {
          var parameters = {};
          $(element).children('.parameter').each((index, element) => {
            parameters[element.name] = element.value;
          });

          // Look for a potential App ID to prepend.
          var authString = '';
          var appIdElement = $(element).find('#appId');
          if (appIdElement.length === 1) {
            var appIdValue = appIdElement.val();
            if (appIdValue !== '') {
              authString = (appIdValue + '@' + accessToken);
            } else {
              authString = accessToken;
            }
          } else {
            authString = accessToken;
          }

          // Send the POST request to the TP.
          if (accessToken !== '') {
            authString = 'Bearer ' + authString;
          } else {
            authString = '';
          }
          var queryPostData = JSON.stringify({
            query,
            variables: parameters,
          });
          $.ajax({
            type: 'POST',
            url: platformUrl,
            data: queryPostData,
            headers: {
              'Authorization' : authString,
              'Content-Type' : 'application/json'
            },
            dataType: 'json',
            success: function (data) {
              outputDisplay.html(JSON.stringify(data, null, 2));
              if (accessToken === '') {
                accessToken = data.data.results.access_tokens[0].access_token;
              }
            },
            error: function (jqXHR, exception) {
              outputDisplay.html(jqXHR.responseText);
            }
          });
        });
      });

      // Modify every parameter input field such that it automatically updates its corresponding parameter display.
      $('.parameter').each((index, element) => {
        $(element).keyup(function() {
          var example = $(element).parent();
          var parameters = {};
          example.children('.parameter').each((index, element) => {
            parameters[element.name] = element.value;
          });

          var newParameterValue = $(element).val();
          parameters[element.name] = element.value;
          var parameterDisplay = $(example).find('.parameter-display');
          parameterDisplay.html(JSON.stringify(parameters, null, 2).trim());
        });

        var example = $(element).parent();
        var parameters = {};
        example.children('.parameter').each((index, element) => {
          parameters[element.name] = element.value;
        });

        var newParameterValue = $(element).val();
        parameters[element.name] = element.value;
        var parameterDisplay = $(example).find('.parameter-display');
        parameterDisplay.html(JSON.stringify(parameters, null, 2).trim());
      });
    </script>

    <!-- Prism.js for performing useful syntax highlighting. -->
    <script type='text/javascript'>
      /* PrismJS 1.15.0
      https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript+csharp+graphql */
      var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-([\w-]+)\b/i,t=0,n=_self.Prism={manual:_self.Prism&&_self.Prism.manual,disableWorkerMessageHandler:_self.Prism&&_self.Prism.disableWorkerMessageHandler,util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).slice(8,-1)},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e,t){var a=n.util.type(e);switch(t=t||{},a){case"Object":if(t[n.util.objId(e)])return t[n.util.objId(e)];var r={};t[n.util.objId(e)]=r;for(var l in e)e.hasOwnProperty(l)&&(r[l]=n.util.clone(e[l],t));return r;case"Array":if(t[n.util.objId(e)])return t[n.util.objId(e)];var r=[];return t[n.util.objId(e)]=r,e.forEach(function(e,a){r[a]=n.util.clone(e,t)}),r}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e],i={};for(var o in l)if(l.hasOwnProperty(o)){if(o==t)for(var s in a)a.hasOwnProperty(s)&&(i[s]=a[s]);a.hasOwnProperty(o)||(i[o]=l[o])}var u=r[e];return r[e]=i,n.languages.DFS(n.languages,function(t,n){n===u&&t!=e&&(this[t]=i)}),i},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){n.highlightAllUnder(document,e,t)},highlightAllUnder:function(e,t,a){var r={callback:a,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",r);for(var l,i=r.elements||e.querySelectorAll(r.selector),o=0;l=i[o++];)n.highlightElement(l,t===!0,r.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1].toLowerCase(),i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,t.parentNode&&(o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l));var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(n.hooks.run("before-sanity-check",u),!u.code||!u.grammar)return u.code&&(n.hooks.run("before-highlight",u),u.element.textContent=u.code,n.hooks.run("after-highlight",u)),n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var g=new Worker(n.filename);g.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,n.hooks.run("after-highlight",u),n.hooks.run("complete",u),r&&r.call(u.element)},g.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,n.hooks.run("after-highlight",u),n.hooks.run("complete",u),r&&r.call(t)},highlight:function(e,t,r){var l={code:e,grammar:t,language:r};return n.hooks.run("before-tokenize",l),l.tokens=n.tokenize(l.code,l.grammar),n.hooks.run("after-tokenize",l),a.stringify(n.util.encode(l.tokens),l.language)},matchGrammar:function(e,t,a,r,l,i,o){var s=n.Token;for(var u in a)if(a.hasOwnProperty(u)&&a[u]){if(u==o)return;var g=a[u];g="Array"===n.util.type(g)?g:[g];for(var c=0;c<g.length;++c){var h=g[c],f=h.inside,d=!!h.lookbehind,m=!!h.greedy,p=0,y=h.alias;if(m&&!h.pattern.global){var v=h.pattern.toString().match(/[imuy]*$/)[0];h.pattern=RegExp(h.pattern.source,v+"g")}h=h.pattern||h;for(var b=r,k=l;b<t.length;k+=t[b].length,++b){var w=t[b];if(t.length>e.length)return;if(!(w instanceof s)){if(m&&b!=t.length-1){h.lastIndex=k;var _=h.exec(e);if(!_)break;for(var j=_.index+(d?_[1].length:0),P=_.index+_[0].length,A=b,x=k,O=t.length;O>A&&(P>x||!t[A].type&&!t[A-1].greedy);++A)x+=t[A].length,j>=x&&(++b,k=x);if(t[b]instanceof s)continue;I=A-b,w=e.slice(k,x),_.index-=k}else{h.lastIndex=0;var _=h.exec(w),I=1}if(_){d&&(p=_[1]?_[1].length:0);var j=_.index+p,_=_[0].slice(p),P=j+_.length,N=w.slice(0,j),S=w.slice(P),C=[b,I];N&&(++b,k+=N.length,C.push(N));var E=new s(u,f?n.tokenize(_,f):_,y,_,m);if(C.push(E),S&&C.push(S),Array.prototype.splice.apply(t,C),1!=I&&n.matchGrammar(e,t,a,b,k,!0,u),i)break}else if(i)break}}}}},tokenize:function(e,t){var a=[e],r=t.rest;if(r){for(var l in r)t[l]=r[l];delete t.rest}return n.matchGrammar(e,a,t,0,0,!1),a},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.length=0|(a||"").length,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if(e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o=Object.keys(l.attributes).map(function(e){return e+'="'+(l.attributes[e]||"").replace(/"/g,"&quot;")+'"'}).join(" ");return"<"+l.tag+' class="'+l.classes.join(" ")+'"'+(o?" "+o:"")+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(n.disableWorkerMessageHandler||_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,n.manual||r.hasAttribute("data-manual")||("loading"!==document.readyState?window.requestAnimationFrame?window.requestAnimationFrame(n.highlightAll):window.setTimeout(n.highlightAll,16):document.addEventListener("DOMContentLoaded",n.highlightAll))),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
      Prism.languages.markup={comment:/<!--[\s\S]*?-->/,prolog:/<\?[\s\S]+?\?>/,doctype:/<!DOCTYPE[\s\S]+?>/i,cdata:/<!\[CDATA\[[\s\S]*?]]>/i,tag:{pattern:/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i,greedy:!0,inside:{tag:{pattern:/^<\/?[^\s>\/]+/i,inside:{punctuation:/^<\/?/,namespace:/^[^\s>\/:]+:/}},"attr-value":{pattern:/=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/i,inside:{punctuation:[/^=/,{pattern:/(^|[^\\])["']/,lookbehind:!0}]}},punctuation:/\/?>/,"attr-name":{pattern:/[^\s>\/]+/,inside:{namespace:/^[^\s>\/:]+:/}}}},entity:/&#?[\da-z]{1,8};/i},Prism.languages.markup.tag.inside["attr-value"].inside.entity=Prism.languages.markup.entity,Prism.hooks.add("wrap",function(a){"entity"===a.type&&(a.attributes.title=a.content.replace(/&amp;/,"&"))}),Prism.languages.xml=Prism.languages.markup,Prism.languages.html=Prism.languages.markup,Prism.languages.mathml=Prism.languages.markup,Prism.languages.svg=Prism.languages.markup;
      Prism.languages.css={comment:/\/\*[\s\S]*?\*\//,atrule:{pattern:/@[\w-]+?.*?(?:;|(?=\s*\{))/i,inside:{rule:/@[\w-]+/}},url:/url\((?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,selector:/[^{}\s][^{};]*?(?=\s*\{)/,string:{pattern:/("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},property:/[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i,important:/!important\b/i,"function":/[-a-z0-9]+(?=\()/i,punctuation:/[(){};:,]/},Prism.languages.css.atrule.inside.rest=Prism.languages.css,Prism.languages.markup&&(Prism.languages.insertBefore("markup","tag",{style:{pattern:/(<style[\s\S]*?>)[\s\S]*?(?=<\/style>)/i,lookbehind:!0,inside:Prism.languages.css,alias:"language-css",greedy:!0}}),Prism.languages.insertBefore("inside","attr-value",{"style-attr":{pattern:/\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i,inside:{"attr-name":{pattern:/^\s*style/i,inside:Prism.languages.markup.tag.inside},punctuation:/^\s*=\s*['"]|['"]\s*$/,"attr-value":{pattern:/.+/i,inside:Prism.languages.css}},alias:"language-css"}},Prism.languages.markup.tag));
      Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0,greedy:!0}],string:{pattern:/(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i,lookbehind:!0,inside:{punctuation:/[.\\]/}},keyword:/\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(?:true|false)\b/,"function":/\w+(?=\()/,number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
      Prism.languages.javascript=Prism.languages.extend("clike",{"class-name":[Prism.languages.clike["class-name"],{pattern:/(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/,lookbehind:!0}],keyword:[{pattern:/((?:^|})\s*)(?:catch|finally)\b/,lookbehind:!0},/\b(?:as|async|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/],number:/\b(?:(?:0[xX][\dA-Fa-f]+|0[bB][01]+|0[oO][0-7]+)n?|\d+n|NaN|Infinity)\b|(?:\b\d+\.?\d*|\B\.\d+)(?:[Ee][+-]?\d+)?/,"function":/[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*\(|\.(?:apply|bind|call)\()/,operator:/-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/}),Prism.languages.javascript["class-name"][0].pattern=/(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/,Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^\/\\\[\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})\]]))/,lookbehind:!0,greedy:!0},"function-variable":{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\([^()]*\)|[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/i,alias:"function"},parameter:[{pattern:/(function(?:\s+[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)[^\s()][^()]*?(?=\s*\))/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/,inside:Prism.languages.javascript},{pattern:/(\(\s*)[^\s()][^()]*?(?=\s*\)\s*=>)/,lookbehind:!0,inside:Prism.languages.javascript},{pattern:/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)[^\s()][^()]*?(?=\s*\)\s*\{)/,lookbehind:!0,inside:Prism.languages.javascript}],constant:/\b[A-Z][A-Z\d_]*\b/}),Prism.languages.insertBefore("javascript","string",{"template-string":{pattern:/`(?:\\[\s\S]|\${[^}]+}|[^\\`])*`/,greedy:!0,inside:{interpolation:{pattern:/\${[^}]+}/,inside:{"interpolation-punctuation":{pattern:/^\${|}$/,alias:"punctuation"},rest:Prism.languages.javascript}},string:/[\s\S]+/}}}),Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(<script[\s\S]*?>)[\s\S]*?(?=<\/script>)/i,lookbehind:!0,inside:Prism.languages.javascript,alias:"language-javascript",greedy:!0}}),Prism.languages.js=Prism.languages.javascript;
      Prism.languages.csharp=Prism.languages.extend("clike",{keyword:/\b(?:abstract|add|alias|as|ascending|async|await|base|bool|break|byte|case|catch|char|checked|class|const|continue|decimal|default|delegate|descending|do|double|dynamic|else|enum|event|explicit|extern|false|finally|fixed|float|for|foreach|from|get|global|goto|group|if|implicit|in|int|interface|internal|into|is|join|let|lock|long|namespace|new|null|object|operator|orderby|out|override|params|partial|private|protected|public|readonly|ref|remove|return|sbyte|sealed|select|set|short|sizeof|stackalloc|static|string|struct|switch|this|throw|true|try|typeof|uint|ulong|unchecked|unsafe|ushort|using|value|var|virtual|void|volatile|where|while|yield)\b/,string:[{pattern:/@("|')(?:\1\1|\\[\s\S]|(?!\1)[^\\])*\1/,greedy:!0},{pattern:/("|')(?:\\.|(?!\1)[^\\\r\n])*?\1/,greedy:!0}],"class-name":[{pattern:/\b[A-Z]\w*(?:\.\w+)*\b(?=\s+\w+)/,inside:{punctuation:/\./}},{pattern:/(\[)[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}},{pattern:/((?:\b(?:class|interface|new)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,lookbehind:!0,inside:{punctuation:/\./}}],number:/\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)f?/i,operator:/>>=?|<<=?|[-=]>|([-+&|?])\1|~|[-+*\/%&|^!=<>]=?/,punctuation:/\?\.?|::|[{}[\];(),.:]/}),Prism.languages.insertBefore("csharp","class-name",{"generic-method":{pattern:/\w+\s*<[^>\r\n]+?>\s*(?=\()/,inside:{"function":/^\w+/,"class-name":{pattern:/\b[A-Z]\w*(?:\.\w+)*\b/,inside:{punctuation:/\./}},keyword:Prism.languages.csharp.keyword,punctuation:/[<>(),.:]/}},preprocessor:{pattern:/(^\s*)#.*/m,lookbehind:!0,alias:"property",inside:{directive:{pattern:/(\s*#)\b(?:define|elif|else|endif|endregion|error|if|line|pragma|region|undef|warning)\b/,lookbehind:!0,alias:"keyword"}}}}),Prism.languages.dotnet=Prism.languages.csharp;
      Prism.languages.graphql={comment:/#.*/,string:{pattern:/"(?:\\.|[^\\"\r\n])*"/,greedy:!0},number:/(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,"boolean":/\b(?:true|false)\b/,variable:/\$[a-z_]\w*/i,directive:{pattern:/@[a-z_]\w*/i,alias:"function"},"attr-name":/[a-z_]\w*(?=\s*:)/i,keyword:[{pattern:/(fragment\s+(?!on)[a-z_]\w*\s+|\.{3}\s*)on\b/,lookbehind:!0},/\b(?:query|fragment|mutation)\b/],operator:/!|=|\.{3}/,punctuation:/[!(){}\[\]:=,]/};
    </script>
  </body>

</html>
